current_tasks:
  display: |
    # To do

    current project: {project_name}
    task type:       {next_task_type_name}

  tables:
    - |
      select
        desc,
        short_task_type,
        '
      ' || coalesce(project_name, '(No project)') || '
      ' as project_name
      from available_tasks;
    - display: "{project_name}    {desc} ({short_task_type})"
      groups:
        - project_name
      
  queries:
    - "with cte as(select name as next_task_type_name from task_types where id = :next_task_type_id union all select null) select * from cte limit 1;"
    - |
      select '
      ' as NL;
  commands:
    - command: "/msm"
      to: modify_standing_meetings
    - command: "/sm"
      to: have_meeting
      queries:
        - choices: |
            select id as meeting_id, name as meeting_name
            from standing_meetings;
          display: "which meetimg?"
          format: "{meeting_name}"
          display: "which meetimg?"
        - | 
            select
              next_instance_id as meeting_instance_id,
              meeting_name,
              meeting_notes
            from next_standing_meetings 
            where meeting_id = :meeting_id;
        - |
          insert into standing_meeting_instances(id, meeting)
          values (:meeting_instance_id, :meeting_id)
            on conflict do nothing;
        - |
          insert into tasks (id, desc, task_type)
          values (
            :meeting_instance_id,
            'Review notes for ' || :meeting_name || ' (' || strftime('%F', datetime(current_timestamp, 'localtime')) || ')',
            (select id from task_types where short_name = 'R')
          ) on conflict do update
            set desc = excluded.desc;
        - |
          with existing_task as (
            select :meeting_instance_id as id
          )
          select
            coalesce(nl.task_id, (select max(id) + 1 from tasks))
              as new_have_meeting_id
          from existing_task as n
          left join task_note_links as nl
            on n.id = nl.note_id
          where n.id = :meeting_instance_id;
        - |
          insert into tasks (id, desc, task_type)
          values (
            :new_have_meeting_id,
            'Have meeting: ' || :meeting_name,
            (select id from task_types where short_name = 'HM')
          ) on conflict do nothing;
        - |
          insert into blocks(blocked, blocker)
          values (:meeting_instance_id, :new_have_meeting_id)
            on conflict do nothing;
        - |
          insert into task_note_links(task_id, note_id)
          values (:new_have_meeting_id, :meeting_instance_id)
            on conflict do nothing;
        - "select :new_have_meeting_id as current_task_id;"
    - command: "/npt"
      to: modify_project_template
      queries:
        - "insert into project_templates(name) values (:__input) returning id as project_template_id;"
    - command: "/mpt"
      to: modify_project_template
      queries:
        - choices: "select id as project_template_id, name as project_template_name from project_templates;"
          format: "{project_template_name}"
          display: "Which template do you want to modify?"
    - command: "/spt"
      queries:
        - choices: "select id as project_template_id, name as project_template_name from project_templates;"
          display: "Which template should we use?"
          format: "{project_template_name}"
        - |
          select case :__input
            when '' then
              :project_template_name || ' ' || datetime(current_timestamp, 'localtime')
            else
              :__input
            end as new_project_name;
        - |
          insert into tasks(desc, task_type)
          values (
            'Call it done: '|| :new_project_name,
            (
              select id
              from task_types
              where short_name = 'P'
            )
          ) returning id as project_id;
        - "update tasks set project = :project_id where id = :project_id;"
        - "insert into projects(id, name, template) values (:project_id, :new_project_name, :project_template_id) on conflict do nothing"
      to: new_project_from_template
    - command: "/vtt"
      to: tasks_of_type
      queries:
        - choices: "select id as task_type_id, name as task_type_name, short_name as task_type_short_name from task_types"
          format: "{task_type_name} ({task_type_short_name})"
          display: "Which task type?"
    - command: "/wf"
      queries:
        - "create temporary table blocked(id integer);"
        - select_from: "select id as selected_task_id, desc as task_decription from available_tasks;"
          format: "{task_description}"
          display: "Which tasks can't we do till '{__input}'?"
          query: "insert into temp.blocked values (:selected_task_id);"
        - "insert into tasks(desc, project, task_type) values (:__input, :project_id, (select id from task_types where short_name = 'WF')) returning id as new_task_id"
        - "insert into blocks(blocked, blocker) select id, :new_task_id from temp.blocked;"
        - "drop table temp.blocked;"
    - command: "/bl"
      queries:
        - "create temporary table blockers(id integer);"
        - "create temporary table blocked(id integer);"
        - select_from: "select id as selected_task_id, desc as task_decription from available_tasks;"
          display: "Which tasks need to be done first?"
          query: "insert into temp.blockers values (:selected_task_id);"
        - select_from: |
            select
              id as selected_task_id,
              desc as task_decription
            from available_tasks as at
            left join temp.blockers as tb on at.id = tb.id
            where tb.id is null;
          display: "Which tasks are blocked?"
          query: "insert into temp.blocked values (:selected_task_id);"
        - |
          insert into blocks(blocked, blocker)
          select blocked.id, blocker.id from temp.blockers, temp.blocked
        - "drop table temp.blockers;"
        - "drop table temp.blocked;"
    - command: "/pl"
      queries:
        - choices: |
            select
              id as project_id,
              name as project_name
            from active_projects;
          format: "{project_name}"
          display: "Which project"
        - |
          update projects
          set priority = (select max(priority) + 1 from active_projects)
          where id = :project_id
    - command: "/ht"
      queries:
        - choices: "select id as current_task_id, desc as task_description from available_tasks;"
          format: "{task_description}"
          display: "Which task should be hidden till {__input}?"
        - |
          update tasks set hide_until = case :__input
            when 'tomorrow' then datetime('now', '1 day', 'localtime', 'start of day', 'utc')
            when 'next week' then datetime('now', '1 day', 'weekday 1', 'localtime', 'start of day', 'utc')
            when 'weekend' then datetime('now', '1 day', 'weekday 6', 'localtime', 'start of day', 'utc')
            else datetime(:__input, 'localtime', 'start of day', 'utc') end
          where id = :current_task_id;
    - command: "/np"
      queries:
        - "insert into tasks(desc, task_type) values ('Come up with next actions: ' || :__input, (select id from task_types where short_name = 'P')) returning id as project_id"
        - "update tasks set project = :project_id where id = :project_id;"
        - "insert into projects(id, name) values (:project_id, :__input) on conflict do nothing"
    - command: "/tt"
      queries:
        - choices: "select id as next_task_type_id, name as next_task_type_name from task_types"
          format: "{next_task_type_name}"
          display: "Which task type should be used next?"
    - command: "/bt"
      to: break_down_task
      queries:
        - choices: "select id as current_task_id, desc as task_description from available_tasks;"
          format: "{task_description}"
          display: "Which task should be broken down?"
    - command: "/vp"
      to: modify_project
      queries:
        - choices: select id as current_task_id, name as project_name from active_projects;
          format: "{project_name}"
          display: "Which project?"
    - command: "/?"
      to: current_tasks_help
    - command: "/p"
      queries:
        - choices: |
            select
              id as project_id,
              name as project_name
            from active_projects;
          format: "{project_name}"
          display: "Which project"
        - |
          update projects
          set priority = priority + 2
          where id in (
            select id from active_projects
          );
        - |
          update projects
          set priority = 0
          where id = :project_id
    - command: "/os"
      queries:
        - |
          update projects
          set priority = priority + 2
          where id in (
            select id from active_projects
          )
        - "select null as project_id;"
        - "select null as project_name;"
        - "select null as next_task_type_id;"
    - command: "/q"
      queries:
        - |
          insert into tasks(desc, task_type, project)
          values (
            :__input,
            (
              select id
              from task_types
              where short_name = 'Q'
            ),
            :project_id
          );
    - command: "/mt"
      to: "modify_task"
      queries:
        - choices: |
            select
              id as current_task_id,
              desc,
              short_task_type,
              project_id,
              project_name
            from available_tasks
            limit 100;
          format: "{desc} ({short_task_type}) - {project_name}"
          display: "which task?"
    - command: "/dt"
      queries:
        - choices: |
            select
              id as task_id,
              desc,
              short_task_type,
              project_id,
              project_name
            from available_tasks
            limit 100;
          format: "{desc} ({short_task_type}) - {project_name}"
          display: "which task?"
        - "update tasks set completed_at = current_timestamp where id = :task_id;"
    - command: "/m"
      queries:
        - "select 'Review notes for ' || :__input as review_meeting_task_desc;"
        - |
          insert into tasks(desc, task_type)
          values (
            :review_meeting_task_desc,
            (select id from task_types where short_name='R')
          ) returning id as meeting_id
        - filename: ".temp_note.md"
          template: "# {__input}"
        - bash: "nvim .temp_note.md"
          system: true
        - bash: "cat .temp_note.md"
          query: "insert into notes(id, note) values(:meeting_id, :__stdout);"
          multiline: false
    - command: "/sq"
      queries:
        - choices: |
            select rowid as question_id, desc as question_text from
            questions_fts
            where desc match :__input
            order by rank
          format: "{question_text}"
          display: "Which matching question?"
        - "insert into notes(id, note) values (:question_id, '') on conflict do nothing;"
        - filename: ".temp_note.md"
          template: "{question_answer_content}"
          query: |
              select
                note as question_answer_content
              from notes
              where id = :question_id
        - bash: "nvim .temp_note.md"
          system: true
        - bash: "cat .temp_note.md"
          query: "update notes set note = :__stdout where id = :question_id;"
    - command: "/sn"
      queries:
        - choices: |
            select
              notes_fts.rowid as note_id,
              notes_fts.note as question_answer_content,
              tasks.desc as task_description
            from
            notes_fts, tasks
            where note match :__input
            and notes_fts.rowid = tasks.id
            order by rank
          format: "{task_description}"
          display: "Which matching question / meeting?"
        - filename: ".temp_note.md"
          template: "{question_answer_content}"
        - bash: "nvim .temp_note.md"
          system: true
        - bash: "cat .temp_note.md"
          query: "update notes set note = :__stdout where id = :note_id;"
    - command: "/st"
      to: "__next"
      queries:
        - display: "Which task?"
          format: "{task_description}"
          choices: |
            select
              id as current_task_id,
              desc as task_description,
              coalesce(workflow, 'answer_question')  as __next
            from available_tasks;
    - queries:
        - |
          insert into tasks(desc, project, task_type)
          values (
            :__input,
            :project_id,
            coalesce(:next_task_type_id, (
              select id
              from task_types
              where short_name = 'S'
            ))
          );

current_tasks_help:
  display: |
    /p Switch a project to be top priority
    /pl bump a project to be lowest priority
    /np (name) new project
    /vp view details about a project
    /os Organize stuff / switch to no project
    /q (question) add a question
    /mt modify a task
    /bt break down a task into smaller pieces
    /st start a task
    /dt Task is done
    /m (meeting name) Start taking notes
    /sq (search term) Search for questions
    /sn Search through notes / answers
    /wf (thing) make a new waiting for task that blocks other tasks
    /vtt See current tasks, limited to a single type
    /tt set the type of the next task to create
    Add a new task (Quick)
    /ht tomorrow: snooze a task till tomorrow
    /ht weekend: snooze a task till the weekend
    /ht next week: snooze a task till next week
    /bl make a set of tasks each block another set of tasks
    /spt (new name for project) start a project from a template
    /npt (name) new project template
    /mpt modify project template
    /msm modify standing meetings
    /sm start the next instance of a standing meeting
  commands:
    - to: current_tasks


modify_standing_meetings:
  display: |
    # Configure standing meetings
    /nm (name)  - add a new meeting
    /ng (name)  - add a new meeting group
    /am         - add a meeting to a group
    /rm         - remove a meeting from a group

    ## Standing meetings
  tables:
    - "select name as meeting_name from standing_meetings;"
    - "{meeting_name}"
    - ""
    - |

      ## Groups
    - |
      select
        mg.name || :NL as group_name,
        '  ' || coalesce(sm.name, '(None)') as meeting_name
      from standing_meeting_groups as mg
      left join standing_meeting_group_mem as gl
        on mg.id = gl.group_id
      left join standing_meetings as sm
        on sm.id = gl.meeting;
    - display: "{group_name}{meeting_name}"
      groups:
        - group_name
  commands:
    - command: "/nm"
      queries:
        - "insert into standing_meetings (name) values (:__input);"
    - command: "/ng"
      queries:
        - "insert into standing_meeting_groups (name) values (:__input);"
    - command: "/am"
      queries:
        - choices: "select id as meeting_id, name as meeting_name from standing_meetings;"
          display: "Which meeting?"
          format: "{meeting_name}"
        - choices: "select id as meeting_group_id, name as meeting_group_name from standing_meeting_groups;"
          display: "To which group?"
          format: "{meeting_group_name}"
        - |
          insert into standing_meeting_group_mem(group_id, meeting)
          values (:meeting_group_id, :meeting_id)
            on conflict do nothing;
    - command: "/rm"
      queries:
        - choices: "select id as meeting_group_id, name as meeting_group_name from standing_meeting_groups;"
          display: "To which group?"
          format: "{meeting_group_name}"
        - choices: |
            select sm.id as meeting_id, name as meeting_name
            from standing_meeting_group_mem as gm
            inner join standing_meetings as sm
              on sm.id = gm.meeting
            where gm.group_id = :meeting_group_id;
          display: "Which meeting?"
          format: "{meeting_name}"
        - "delete from standing_meeting_group_mem where group_id = :meeting_group_id and meeting = :meeting_id;"
    - command: "/b"
      to: current_tasks
        

modify_project_template:
  queries:
    - "select name as project_template_name from project_templates where id = :project_template_id;"
    - |
      select '
      ' as __NL;
  display: |
    # {project_template_name} (/cn (name) to change the name)
    /edit       edit the tasks, fields of the project
    /deps       edit the dependancies between tasks
    /b          Go back

    ## Fields
  tables:
    - |
      select distinct tf.name as field_name
      from project_template_tasks as tt
      inner join project_template_fields as tf
        on tf.id = tt.format_field
      where tt.template = :project_template_id;
    - "{field_name}"
    - ""
    - "## Tasks"
    - |
      select
        :__NL || format(tt.task_desc, '(' || tf.name || ')') || '(' || tts.short_name || ')' || :__NL as task_description,
        bt.task_desc as blocked_task_description
      from project_template_tasks as tt
      inner join task_types as tts
        on tt.task_type = tts.id
      left join project_template_task_links as ttl
        on tt.id = ttl.blocker
      left join project_template_tasks as bt
        on ttl.blocked = bt.id
      left join project_template_fields as tf
        on tt.format_field = tf.id
      where tt.template = :project_template_id;
    - display: "{task_description}    {blocked_task_description}"
      groups:
        - task_description
  commands:
    - command: "/cn"
      queries:
        - "update project_templates set name = :__input where id = :project_template_id;"
    - command: "/edit"
      queries:
        - filename: ".temp_note.md"
          template: "{line}"
          query: |
            select '# Tasks for template: ' || :project_template_name || :__NL || :__NL as line
            union all
            select tt.task_desc ||'|'|| coalesce(tf.name, '') ||'|'|| tts.short_name ||'|'|| tt.id || :__NL as line
            from project_template_tasks as tt
            inner join task_types as tts
              on tt.task_type = tts.id
            left join project_template_fields as tf
              on tt.format_field = tf.id
            where tt.template = :project_template_id
        - bash: "nvim .temp_note.md"
          system: true
        - "create temporary table updated_template_tasks(desc text, field_name text, short_task_type text, id integer);"
        - bash: "cat .temp_note.md"
          query: |
            with new_id as (
              select cast(coalesce(:__4, 0) as integer) as id
            )
            insert into temp.updated_template_tasks(desc, field_name, short_task_type, id)
            values (:__1, :__2, :__3,
              (select case id
                when 0 then coalesce((select max(id)+1 from (select id from project_template_tasks union all select id from temp.updated_template_tasks)), 1)
                else id
                end
              from new_id
              limit 1)
            )
        - "delete from temp.updated_template_tasks where trim(desc) like '#%' or trim(desc) == '';"
        - |
          insert into project_template_fields(name)
          select trim(utt.field_name)
          from temp.updated_template_tasks as utt
          left join project_template_fields as tf
            on utt.field_name = tf.name
          where tf.id is NULL
          and trim(coalesce(utt.field_name, '')) <> '';
        - "delete from project_template_tasks where id in (select id from temp.updated_template_tasks);"
        - insert into project_template_tasks(id, template, task_desc, format_field, task_type)
          select
            utt.id,
            :project_template_id, 
            trim(utt.desc),
            tf.id,
            coalesce(tts.id, (select id from task_types where short_name = 'S'))
          from temp.updated_template_tasks as utt
          left join project_template_fields as tf
            on tf.name = trim(utt.field_name)
          left join task_types as tts
            on trim(utt.short_task_type) = tts.short_name;
        - "drop table temp.updated_template_tasks;"
    - command: "/deps"
      queries:
        - filename: ".temp_note.md"
          template: "{line}"
          query: |
            select '# Dependancies for ' || :project_template_name || :__NL || :__NL as line
            union all
            select '## Tasks' || :__NL || :__NL as line
            union all
            select tt.id || ': ' || tt.task_desc || :__NL as line
            from project_template_tasks as tt
            where tt.template = :project_template_id
            union all
            select :__NL || '## Dependancies (blocker | blocked)' || :__NL || :__NL as line
            union all
            select distinct tl.blocker || '  |  ' || tl.blocked as line
            from project_template_task_links as tl
            inner join project_template_tasks as tt1
              on tl.blocker = tt1.id
            inner join project_template_tasks as tt2
              on tl.blocked = tt2.id
            where tt1.template = :project_template_id
            and tt2.template = :project_template_id
        - bash: "nvim .temp_note.md"
          system: true
        - "create temporary table updated_task_links(blocker text, blocked text);"
        - bash: "cat .temp_note.md"
          query: "insert into temp.updated_task_links(blocker, blocked) values ((select trim(:__1)), (select trim(:__2))"
        - "delete from temp.updated_task_links where trim(blocker) like '#%' or trim(blocker) == '';"
        - |
          delete from project_template_task_links where id in (
            select distinct tl.id
            from project_template_task_links as tl
            inner join project_template_tasks as tt1
              on tl.blocker = tt1.id
            inner join project_template_tasks as tt2
              on tl.blocked = tt2.id
            where tt1.template = :project_template_id
            and tt2.template = :project_template_id
          );
        - |
          with correct_links as (
            select
              cast(coalesce(blocker, 0) as integer) as blocker,
              cast(coalesce(blocked, 0) as integer) as blocked
            from temp.updated_task_links
          )
          insert into project_template_task_links(blocker, blocked)
          select blocker, blocked from correct_links
          where blocker <> 0 and blocked <> 0;
        - "drop table temp.updated_task_links;"
    - command: "/b"
      to: current_tasks

new_project_from_template:
  display: |
    # {new_project_name}
    ok            - create these tasks
    /data         - pick a field to set
    /set (field)  - set a field
    /b            - cancel and don't create tasks

    ## Fields:
  tables:
    - |
      select field_name, field_value
      from denorm_project_data
      where project_id = :project_id;
    - "{field_name}: {field_value}"
    - ""
    - |
      
      # Tasks
    - "select desc as new_task_desc from generated_project_tasks where project = :project_id"
    - "    {new_task_desc}"
  commands:
    - command: "/set"
      queries:
        - "select null as field_id"
        - "select field_id from denorm_project_data where field_name = :__input and project_id = :project_id;"
        - "delete from project_data where project = :project_id and field = :field_id and :field_id is not null;"
        - prompt: "What value to set?"
          target: field_value
        - |
          insert into project_data(project, field, value)
          select :project_id, :field_id, :field_value
          where :field_id is not null;
    - command: "/data"
      queries:
        - choices: "select field_id, field_name from denorm_project_data where project_id = :project_id;"
          display: "which field?"
          format: "{field_name}"
        - prompt: "What value to set?"
          target: field_value
        - "delete from project_data where project = :project_id and field = :field_id;"
        - "insert into project_data(project, field, value) values (:project_id, :field_id, :field_value);"
    - command: "/b"
      to: current_tasks
    - command: "ok"
      to: current_tasks
      queries:
        - |
          insert into tasks (source, desc, project, task_type)
          select source, desc, project, task_type
          from generated_project_tasks
          where project = :project_id;
        - insert into blocks(blocked, blocker)
          select blocked, blocker
          from generated_project_links
          where project_id = :project_id

tasks_of_type:
  display: |
    # {task_type_name} Tasks
    
    (/dt mark as done, /st start task, /b go back)
  tables:
    - |
      select
        desc as task_description
      from available_tasks
      where task_type_id = :task_type_id
    - "{task_description}"
  queries:
    - "select name as task_type_name from task_types where id = :task_type_id;"
  commands:
    - command: "/st"
      to: "__next"
      queries:
        - display: "Which task?"
          format: "{task_description}"
          choices: |
            select
              id as current_task_id,
              desc as task_description,
              coalesce(workflow, 'answer_question')  as __next
            from available_tasks
            where task_type_id = :task_type_id;
    - command: "/b"
      to: current_tasks
    - command: "/dt"
      queries:
        - choices: |
            select 
              id as done_task_id,
              desc as task_description
            from available_tasks
            where task_type_id = :task_type_id;
          format: "{task_description}"
          display: "Which is now done?"
        - "update tasks set completed_at = current_timestamp where id = :done_task_id;"

break_down_task:
  display: |
    # Break down task ("/b" to go back)

    Task:    {task_description}
    Project: {project_name}

  queries:
    - select project_id, project_name, desc as task_description from tasks_denorm where id = :current_task_id
  tables:
    - |
      select
        t.desc as blocker_task_description
      from tasks as t, blocks as b
      where
        b.blocked = :current_task_id
        and b.blocker = t.id;
    - "    {blocker_task_description}"
  commands:
    - command: "/b"
      to: current_tasks
    - queries:
        - "insert into tasks(desc, project, task_type) values (:__input, :project_id, (select id from task_types where short_name = 'T')) returning id as new_task_id"
        - "insert into blocks(blocked, blocker) values (:current_task_id, :new_task_id);"

have_meeting:
  queries:
    - |
      select
        note_id as note_id
      from task_notes
      where task_id = :current_task_id
      limit 1;
    - |
      select 
        sm.name as meeting_name
      from standing_meeting_instances as mi
      inner join standing_meetings as sm
        on sm.id = mi.meeting
      where mi.id = :note_id;
    - |
      insert into notes(id, note)
      values (
        :note_id,
        '# ' || :meeting_name
        ) on conflict do nothing;
    - "select note as notes_content from notes where id = :note_id;"
    - edit: notes_content
    - |
      update notes
      set note = :notes_content
      where id = :note_id;
  display: "Has the meeting now finished? (y/n)"
  commands:
    - command: "y"
      to: current_tasks
      queries:
        - |
          update tasks
          set completed_at = current_timestamp
          where id = :current_task_id;
        - |
          update standing_meeting_instances
          set completed_at = current_timestamp
          where id = :note_id;
    - command: "n"
      to: current_tasks


answer_question:
  queries:
    - |
      select
        note_id as note_id
      from task_notes
      where task_id = :current_task_id
      limit 1;
    - |
      insert into notes(id, note)
      values (
        :note_id,
        '# ' || (
          select desc
          from tasks
          where id = :current_task_id
        )) on conflict do nothing;
    - "select note as notes_content from notes where id = :note_id;"
    - filename: ".temp_note.md"
      template: "{notes_content}"
    - bash: "nvim .temp_note.md"
      system: true
    - bash: "cat .temp_note.md"
      query: |
        update notes
        set note = :__stdout
        where id = :note_id;
      multiline: false
  display: "Is this now done? (y/n)"
  commands:
    - command: "y"
      to: current_tasks
      queries:
        - |
          update tasks
          set completed_at = current_timestamp
          where id = :current_task_id;
    - command: "n"
      to: current_tasks

modify_task:
  queries:
    - |
      select
        desc as task_description,
        task_type,
        project_id as project_id,
        project_name,
        created_at as task_created_at_time,
        hide_until as task_hidden_till_time
      from tasks_denorm
      where id = :current_task_id
  display: |
    # Modify task

    Description /cd: {task_description}
    Type /tt:        {task_type}
    Project /cp:     {project_name}
    created:         {task_created_at_time}
    hidden till /ht: {task_hidden_till_time}
      /ht tomorrow
      /ht next week
      /ht 2025-06-01

    /np   this is a new project
    /pd   this is a piece of data for a project
    /qa   this is part of an answer to a question
    /pn   this is a general project note
    /ma   this is a note that should go on the agenda for a meeting
    /mga  this is a note that should on the agenda for all meetings in a group
    /b back

  commands:
    - command: "/mga"
      queries:
        - choices: |
            select
              id as group_id,
              name as group_name 
            from standing_meeting_groups;
          format: "{group_name}"
          display: "Which group?"
        - |
          insert into notes(id, note)
          select
            next_instance_id as meeting_notes_id,
            meeting_notes || :__NL || :task_description as meeting_notes
          from next_standing_meetings
          where meeting_id in (
            select sm.id
              from standing_meetings as sm
              inner join standing_meeting_group_mem as gm
                on sm.id = gm.meeting
              where gm.group_id = :group_id
          )
            on conflict do update
            set note = excluded.note;
    - command: "/ma"
      to: current_tasks
      queries:
        - choices: |
            select
              id as meeting_id,
              name as meeting_name
            from standing_meetings;
          format: "{meeting_name}"
          display: "Which meeting?"
        - | 
            select
              next_instance_id as meeting_instance_id,
              meeting_name,
              meeting_notes || :__NL || :task_description as meeting_notes
            from next_standing_meetings 
            where meeting_id = :meeting_id;
        - |
          insert into standing_meeting_instances(id, meeting)
          values (:meeting_instance_id, :meeting_id)
            on conflict do nothing;
        - |
          insert into tasks (id, desc, task_type)
          values (
            :meeting_instance_id,
            'Review notes for ' || :meeting_name || ' (' || strftime('%F', datetime(current_timestamp, 'localtime')) || ')',
            (select id from task_types where short_name = 'R')
          ) on conflict do nothing;
        - |
          with existing_task as (
            select :meeting_instance_id as id
          )
          select
            coalesce(nl.task_id, (select max(id) + 1 from tasks))
              as new_have_meeting_id
          from existing_task as n
          left join task_note_links as nl
            on n.id = nl.note_id
          where n.id = :meeting_instance_id;
        - |
          insert into tasks (id, desc, task_type)
          values (
            :new_have_meeting_id,
            'Have meeting: ' || :meeting_name,
            (select id from task_types where short_name = 'HM')
          ) on conflict do nothing;
        - |
          insert into blocks(blocked, blocker)
          values (:meeting_instance_id, :new_have_meeting_id)
            on conflict do nothing;
        - |
          insert into task_note_links(task_id, note_id)
          values (:new_have_meeting_id, :meeting_instance_id)
            on conflict do nothing;
        - |
          insert into notes(id, note)
          values (:meeting_instance_id, :meeting_notes)
            on conflict do update
            set note = excluded.note;
        - "update tasks set completed_at = current_timestamp where id = :current_task_id;"
    - command: "/pn"
      to: current_tasks
      queries:
        - "select project_id, project_name from tasks_denorm where id = :current_task_id;"
        - display: "Which project is this a note for?"
          choices: "select id as project_id, name as project_name from active_projects;"
          format: "{project_name}"
          null_check: project_id
        - "insert into notes(id, note) values (:project_id, '# ' || :project_name) on conflict do nothing;"
        - |
          update notes set note = note || '

          ' || :task_description
          where id = :project_id;
        - "update tasks set completed_at = current_timestamp where id = :current_task_id;"
    - command: "/pd"
      queries:
        - display: "Which project?"
          choices: "select id as project_id, name as project_name from active_projects;"
          format: "{project_name}"
        - display: "which field"
          choices: |
            select
              id as field_id,
              name as field_name,
              name as displayed_field_name
            from project_template_fields
            union all
            select
              max(id) + 1 as field_id,
              :__input as field_name,
              :__input || ' (new)' as displayed_field_name
            from project_template_fields;
        - prompt: "What value?"
          display: "{task_description}"
          target: "field_value"
        - "insert into project_template_fields(id, name) values (:field_id, field_name) on conflict do nothing;"
        - "insert into project_data(project, field, value) values (:project_id, :field_id, :field_valuie);"
    - command: "/np"
      to: current_tasks
      queries:
        - "insert into projects(id, name) values (:current_task_id, :task_description) on conflict do nothing"
        - |
          update tasks set
            task_type = (select id from task_types where short_name = 'P'),
            project = :current_task_id,
            desc = 'Come up with next actions: ' || :task_description
          where id = :current_task_id
    - command: "/ht"
      queries:
        - |
          update tasks set hide_until = case :__input
            when 'tomorrow' then datetime('now', '1 day', 'localtime', 'start of day', 'utc')
            when 'next week' then datetime('now', '1 day', 'weekday 1', 'localtime', 'start of day', 'utc')
            when 'weekend' then datetime('now', '1 day', 'weekday 6', 'localtime', 'start of day', 'utc')
            else datetime(:__input, 'localtime', 'start of day', 'utc') end
          where id = :current_task_id;
    - command: "/cp"
      queries:
        - choices: |
            select
              id as selected_project_id,
              name as selected_project_name
            from active_projects
            union all
            select
              null as project_id,
              "(no project)" as project_name;
          format: "{selected_project_name}"
          display: "which project?"
        - "update tasks set project = :selected_project_id where id = :current_task_id"
    - command: "/cd"
      queries:
        - "update tasks set desc = :__input where id = :current_task_id"
    - command: "/tt"
      queries:
        - choices: |
            select
              id as selected_task_type_id,
              short_name as selected_task_short_name,
              name as selected_task_type_name
            from task_types
            where short_name <> 'P';
          format: "{selected_task_type_name} ({selected_task_short_name})"
          display: "Which type should it become?"
        - "update tasks set task_type = :selected_task_type_id where id = :current_task_id"
    - command: "/b"
      to: current_tasks

modify_project:
  display: |
    # Project: {project_name} (/b to go back, /en to edit notes, otherwise add tasks)
    {project_notes}
    # Tasks:
  queries:
    - "select :current_task_id as project_id"
    - "select name as project_name from projects where id = :project_id"
    - "select '# ' || :project_name as project_notes;"
    - "select note as project_notes from notes where id = :project_id"
  tables:
    - |
      select
        desc || case completed_at is null when 1 then '' else ' (done)' end as task_description
      from tasks
      where project = :project_id
      order by completed_at is not null, created_at desc;
    - "    {task_description}"
  commands:
    - command: "/b"
      to: current_tasks
    - command: "/en"
      queries:
        - edit: project_notes
        - "insert into notes(id, note) values (:project_id, :project_notes) on conflict do update set note = excluded.note;"
    - queries:
      - |
        insert into tasks(desc, task_type, project)
          values (
            :__input,
            (
              select id
              from task_types
              where short_name = 'T'
            ),
            :project_id
          );

review_notes:
  display: |
    # Review: {task_description}
    /b to go back                   /p switch projects
    /np (project name) new project  /en to edit notes
    /d done                         otherwise add tasks

    {meeting_notes}
    Project: {project_name}
    Date: {note_created_at}

    # Tasks
  queries:
    - |
      select
        desc as task_description,
        project_id,
        project_name,
        datetime(created_at, 'localtime') as note_created_at
      from tasks_denorm
      where id = :current_task_id;
    - "select note as meeting_notes from notes where id = :current_task_id"
  tables:
    - |
      select t.desc as dependant_task
      from tasks as t, blocks as b
      where b.blocker = :current_task_id
      and t.id = b.blocked
      order by completed_at is not null, created_at desc;
    - "    {dependant_task}"
  commands:
    - command: "/np"
      queries:
        - "insert into tasks(desc, task_type) values ('Come up with next actions: ' || :__input, (select id from task_types where short_name = 'P')) returning id as project_id"
        - "update tasks set project = :project_id where id = :project_id;"
        - "insert into projects(id, name) values (:project_id, :__input) on conflict do nothing"
        - "update tasks set project = :project_id where id = :current_task_id"
    - command: "/p"
      queries:
        - choices: |
            select
              id as project_id,
              name as project_name
            from active_projects;
          format: "{project_name}"
          display: "Which project"
        - "update tasks set project = :project_id where id = :current_task_id"
    - command: "/d"
      to: current_tasks
      queries:
        - "update tasks set completed_at = current_timestamp where id = :current_task_id;"
    - command: "/b"
      to: current_tasks
    - command: "/en"
      queries:
        - "insert into notes(id, note) values (:current_task_id, '# ' || :task_description) on conflict do nothing;"
        - filename: ".temp_note.md"
          template: "{meeting_notes}"
        - bash: "nvim .temp_note.md"
          system: true
        - bash: "cat .temp_note.md"
          query: "update notes set note = :__stdout where id = :current_task_id;"
    - queries:
      - |
        insert into tasks(desc, task_type, project)
          values (
            :__input,
            (
              select id
              from task_types
              where short_name = 'S'
            ),
            :project_id
          ) returning id as new_task_id;
      - "insert into blocks(blocker, blocked) values (:current_task_id, :new_task_id);"

brainstorm_actions:
  queries:
    - filename: ".temp_note.md"
      template: "# Come up with next actions for {task_description}"
    - bash: "nvim .temp_note.md"
      system: true
    - bash: "cat .temp_note.md"
      query: "update notes set note = :__stdout where id = :current_task_id;"

schema_change_on_load: |
    drop view if exists tasks_denorm;
    create view tasks_denorm as
      select
        t.id as id,
        t.desc as desc,
        t.project as project_id,
        p.name as project_name,
        t.task_type as task_type_id,
        tt.short_name as short_task_type,
        tt.name as task_type,
        coalesce(tt.workflow, 'current_tasks') as workflow,
        t.created_at,
        t.hide_until,
        t.completed_at
      from tasks as t
      left join task_types as tt
      on tt.id = t.task_type
      left join projects as p
      on t.project = p.id;

    drop view if exists available_tasks;
    CREATE VIEW available_tasks as
      with undone_unsnoozed_tasks as (
        select *
        from tasks as t
        where completed_at is NULL
        and (hide_until is NULL or hide_until < current_timestamp)
      ),
      blocked_by as (
        select
          b.blocked as blocked,
          b.blocker as blocker,
          t.completed_at as completed_at
        from blocks as b
        inner join tasks as t on t.id = b.blocker
        where t.completed_at is null
        union
        select
          t.project as blocked,
          t.id as blocker,
          t.completed_at as completed_at
        from tasks as t
        where t.completed_at is null
        and t.project is not null
        and t.project <> t.id
      )
      select
        t.id as id,
        t.desc as desc,
        t.project as project_id,
        p.name as project_name,
        t.task_type as task_type_id,
        tt.short_name as short_task_type,
        tt.workflow as workflow,
        t.created_at,
        t.hide_until,
        t.completed_at
      from undone_unsnoozed_tasks as t
      left join blocked_by as b on t.id = b.blocked
      left join projects as p on t.project = p.id
      left join task_types as tt on t.task_type = tt.id
      where b.blocker is null
      order by coalesce(p.priority, 1) desc, p.id desc, t.created_at desc;

    drop view if exists active_projects;
    CREATE VIEW active_projects as
      with undone_task_count as (
        select
          count(*) as tc,
          project as project
        from tasks
        where completed_at is null
        group by project
      )
      select
        p.id,
        p.created_at,
        p.name,
        p.template,
        p.priority
      from projects as p
      inner join undone_task_count as t
      on p.id = t.project
      where t.tc > 0
      order by p.priority asc, p.created_at desc;

    drop view if exists generated_project_tasks;
    CREATE VIEW generated_project_tasks as
      select
        tt.id as source,
        format(tt.task_desc, pd.value) as desc,
        p.id as project,
        tt.task_type as task_type
      from project_template_tasks as tt
      inner join projects as p
        on p.template = tt.template
      left join project_data as pd
        on tt.format_field = pd.field
        and p.id = pd.project;

    drop view if exists generated_project_links;
    CREATE VIEW generated_project_links as
      select
        t1.project as project_id,
        t1.id as blocker,
        t2.id as blocked
      from
        tasks as t1,
        tasks as t2,
        project_template_task_links as ptl
      where t1.source = ptl.blocker
      and t2.source = ptl.blocked
      and t1.project = t2.project;

    drop view if exists denorm_project_data;
    create view denorm_project_data as
      select
        p.id as project_id,
        tf.id as field_id,
        tf.name as field_name,
        pd.value as field_value
      from project_template_tasks as tt
      inner join project_template_fields as tf
        on tt.format_field = tf.id
      inner join projects as p
        on p.template = tt.template
      left join project_data as pd
        on (pd.field = tf.id and pd.project = p.id);

    create table if not exists standing_meetings(
      id integer primary key,
      created_at timestamp default current_timestamp,
      name text
    );

    create table if not exists standing_meeting_groups(
      id integer primary key,
      created_at timestamp default current_timestamp,
      name text
    );

    create table if not exists standing_meeting_group_mem(
      id integer primary key,
      meeting integer,
      group_id integer
    );

    create unique index if not exists
    standing_meeting_group_mem_uniq_idx
      on standing_meeting_group_mem(meeting, group_id);

    create table if not exists standing_meeting_instances(
      id integer primary key,
      created_at timestamp default current_timestamp,
      meeting integer,
      completed_at timestamp
    );

    drop view if exists next_standing_meetings;
    create view next_standing_meetings as 
    select
      m.id as meeting_id,
      coalesce(mi.id, (select max(id)+1 from tasks)) as next_instance_id,
      m.name as meeting_name,
      coalesce(n.note, '# ' || m.name) as meeting_notes
    from standing_meetings as m
    left join standing_meeting_instances as mi
      on mi.meeting = m.id
      and mi.completed_at is null
    left join notes as n
      on n.id = mi.id;

    create table if not exists task_note_links(
      id integer primary key,
      task_id integer,
      note_id integer
    );

    create unique index if not exists
    task_note_links_uniq_idx
      on task_note_links(task_id, note_id);

    create unique index if not exists
    blocks_uniq_idx
      on blocks(blocker, blocked);

    drop view if exists task_notes;
    create view task_notes as
    select
      t.id as task_id,
      coalesce(tn.note_id, t.id) as note_id
    from tasks as t
    left join task_note_links as tn
      on tn.task_id = t.id;

    create unique index if not exists
      task_types_short_name_unique_idx
      on task_types(short_name);

    insert into task_types(short_name, name, workflow)
      values ('HM', 'Have a meeting and take notes', 'have_meeting')
      on conflict do nothing;

    insert into task_types(short_name, name)
      values ('ER', 'Errands / shopping')
      on conflict do nothing;

    insert into task_types(short_name, name)
      values ('CO', 'Computer / online shopping')
      on conflict do nothing;

schema:
  display: |
    CREATE TABLE tasks(
      id integer primary key,
      source integer,
      desc text,
      project integer,
      task_type integer,
      created_at timestamp default current_timestamp,
      hide_until timestamp,
      completed_at timestamp);

    CREATE TABLE blocks(
      id integer primary key,
      blocked integer,
      blocker integer);

    CREATE TABLE task_types(
      id integer primary key,
      short_name text,
      name text,
      workflow text);

    insert into task_types(short_name, name, workflow)
     values ('P', 'Project', 'modify_project');
    insert into task_types(short_name, name)
     values ('WF', 'Waiting For');
    insert into task_types(short_name, name)
     values ('R', 'Review Notes', 'review_notes');
    insert into task_types(short_name, name)
     values ('Q', 'Question');
    insert into task_types(short_name, name)
     values ('T', 'General Task');
    insert into task_types(short_name, name, workflow)
     values ('S', 'Stuff', 'modify_task');

    CREATE VIRTUAL TABLE questions_fts USING fts5(desc, content='tasks', content_rowid='id');
    CREATE TRIGGER questions_fts_ai AFTER INSERT on tasks
    WHEN new.task_type = (select id from task_types where short_name = 'Q')
    BEGIN
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;
    CREATE TRIGGER questions_fts_ad AFTER DELETE on tasks
    WHEN old.task_type = (select id from task_types where short_name = 'Q')
    BEGIN
      insert into questions_fts(questions_fts, rowid, desc) values('delete', old.id, old.desc);
    END;
    CREATE TRIGGER questions_fts_au_was_question AFTER UPDATE on tasks
    WHEN old.task_type = (select id from task_types where short_name = 'Q') and new.task_type = old.task_type
    BEGIN
      insert into questions_fts(questions_fts, rowid, desc) values('delete', old.id, old.desc);
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;
    CREATE TRIGGER questions_fts_au_new_is_question AFTER UPDATE on tasks
    WHEN new.task_type = (select id from task_types where short_name = 'Q') and old.task_type <> new.task_type
    BEGIN
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;

    CREATE TABLE projects(
      id integer primary key,
      created_at timestamp default current_timestamp,
      name text,
      template integer,
      priority integer not null default 2);

    CREATE TABLE notes (
      id integer primary key,
      note text);

    CREATE VIRTUAL TABLE notes_fts USING fts5(note, content='notes', content_rowid='id');
    CREATE TRIGGER notes_fts_ai AFTER INSERT on notes
    BEGIN
      insert into notes_fts(rowid, note) values(new.id, new.note);
    END;
    CREATE TRIGGER notes_fts_ad AFTER DELETE on notes
    BEGIN
      insert into notes_fts(notes_fts, rowid, note) values('delete', old.id, old.note);
    END;
    CREATE TRIGGER notes_fts_au AFTER UPDATE on notes
    BEGIN
      insert into notes_fts(notes_fts, rowid, note) values('delete', old.id, old.note);
      insert into notes_fts(rowid, note) values(new.id, new.note);
    END;

    CREATE TABLE project_templates(
      id integer primary key,
      name text,
      project_name text,
      created_at timestamp default current_timestamp);

    CREATE TABLE project_template_fields(
      id integer primary key,
      name text);

    CREATE TABLE project_data(
      id integer primary key,
      project integer,
      field integer,
      value text);

    CREATE TABLE project_template_tasks(
      id integer primary key,
      template integer,
      task_desc text,
      format_field integer,
      task_type integer);

    CREATE TABLE project_template_task_links(
      id integer primary key,
      blocked integer,
      blocker integer);
