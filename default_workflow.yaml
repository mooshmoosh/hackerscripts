current_tasks:
  display: |
    # To do

    Commands:
      /p Switch a project to be top priority
      /vp view details about a project
      /os Organize stuff / switch to no project
      /q (question) add a question
      Add a new task (Quick)
      /mt modify a task
      /st start a task
      /dt Task is done
      /m (meeting name) Start taking notes
      /sq (search term) Search for questions
      /sn Search through notes / answers
      /wf (thing) make a new waiting for task
      /vwf See the things I'm waiting for
      snooze a task till tomorrow
      snooze a task till next week
      modify project template
      apply a template of tasks to a project
      bump a project to be last
      make a set of tasks block one task
      make one task block a set of tasks

  tables:
    - |
      select
        desc,
        short_task_type,
        project_name
      from available_tasks;
    - "  {desc} ({short_task_type}) - {project_name}"
  commands:
    - command: "/p"
      queries:
        - choices: |
            select
              id as project_id, 
              name as project_name
            from active_projects;
          format: "{project_name}"
          display: "Which project"
        - |
          update projects
          set priority = priority + 2
          where id in (
            select id from active_projects
          );
        - |
          update projects
          set priority = 0
          where id = :project_id
    - command: "/os"
      queries:
        - |
          update projects
          set priority = priority + 2
          where id in (
            select id from active_projects
          )
        - "select null as project_id;"
        - "select null as project_name;"
    - command: "/q"
      queries:
        - |
          insert into tasks(desc, task_type, project)
          values (
            :__input,
            (
              select id
              from task_types
              where short_name = 'Q'
            ),
            :project_id
          );
    - command: "/mt"
      to: "modify_task"
      queries:
        - choices: |
            select
              id as task_id,
              desc,
              short_task_type,
              project_id,
              project_name
            from available_tasks
            limit 100;
          format: "{desc} ({short_task_type}) - {project_name}"
          display: "which task?"
    - command: "/dt"
      queries:
        - choices: |
            select
              id as task_id,
              desc,
              short_task_type,
              project_id,
              project_name
            from available_tasks
            limit 100;
          format: "{desc} ({short_task_type}) - {project_name}"
          display: "which task?"
        - "update tasks set completed_at = current_timestamp where id = :task_id;"
    - command: "/m"
      queries:
        - "select 'Review notes for ' || :__input as review_meeting_task_desc;"
        - |
          insert into tasks(desc, task_type)
          values (
            :review_meeting_task_desc,
            (select id from task_types where short_name='R')
          ) returning id as meeting_id
        - bash: "touch /tmp/meeting_{meeting_id}.md"
        - bash: "nvim /tmp/meeting_{meeting_id}.md"
          system: true
        - bash: "cat /tmp/meeting_{meeting_id}.md"
          query: "insert into notes(id, note) values(:meeting_id, :__stdout);"
          multiline: false
    - command: "/sq"
      queries:
        - choices: |
            select rowid as question_id, desc as question_text from
            questions_fts 
            where desc match :__input
            order by rank
          format: "{question_text}"
          display: "Which matching question?"
        - "insert into notes(id, note) values (:question_id, '') on conflict do nothing;"
        - filename: "/tmp/question_answer_tmp.md"
          template: "{question_answer_content}"
          query: |
              select
                note as question_answer_content
              from notes
              where id = :question_id
        - bash: "nvim /tmp/question_answer_tmp.md"
          system: true
        - bash: "cat /tmp/question_answer_tmp.md"
          query: "update notes set note = :__stdout where id = :question_id;"
    - command: "/sn"
      queries:
        - choices: |
            select
              notes_fts.rowid as note_id,
              notes_fts.note as question_answer_content,
              tasks.desc as task_description
            from
            notes_fts, tasks
            where note match :__input
            and notes_fts.rowid = tasks.id
            order by rank
          format: "{task_description}"
          display: "Which matching question / meeting?"
        - filename: "/tmp/question_answer_tmp.md"
          template: "{question_answer_content}"
        - bash: "nvim /tmp/question_answer_tmp.md"
          system: true
        - bash: "cat /tmp/question_answer_tmp.md"
          query: "update notes set note = :__stdout where id = :note_id;"
    - command: "/st"
      to: "__next"
      queries:
        - display: "Which task?"
          format: "{task_description}"
          choices: |
            select
              id as current_task_id,
              desc as task_description,
              workflow as __next
            from available_tasks;
    - queries:
        - |
          insert into tasks(desc, project, task_type)
          values (
            :__input,
            :project_id,
            (
              select id
              from task_types
              where short_name = 'S'
            )
          );

modify_task:
  display: |
    # Modify task
    
    commands:
      this is a project
      this is a question for an existing project
      this is a general task on a project
      this is a piece of data for a project
      this is an answer to a question
      change the description
      change the type
    
    description: {desc}

schema:
  display: |
    CREATE TABLE tasks(
      id integer primary key,
      source integer,
      desc text,
      project integer,
      task_type integer,
      created_at timestamp default current_timestamp,
      hide_until timestamp,
      completed_at timestamp);

    CREATE TABLE blocks(
      id integer primary key,
      blocked integer,
      blocker integer);

    CREATE TABLE task_types(
      id integer primary key,
      short_name text,
      name text,
      workflow text);

    insert into task_types(short_name, name, workflow)
     values ('P', 'Project', 'modify_project');
    insert into task_types(short_name, name)
     values ('WF', 'Waiting For');
    insert into task_types(short_name, name, workflow)
     values ('R', 'Review Notes', 'edit_notes');
    insert into task_types(short_name, name, workflow)
     values ('Q', 'Question', 'answer_question');
    insert into task_types(short_name, name, workflow)
     values ('T', 'General Task', 'answer_question');
    insert into task_types(short_name, name, workflow)
     values ('S', 'Stuff', 'modify_task');

    CREATE VIRTUAL TABLE questions_fts USING fts5(desc, content='tasks', content_rowid='id');
    CREATE TRIGGER questions_fts_ai AFTER INSERT on tasks
    WHEN new.task_type = (select id from task_types where short_name = 'Q')
    BEGIN
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;
    CREATE TRIGGER questions_fts_ad AFTER DELETE on tasks
    WHEN old.task_type = (select id from task_types where short_name = 'Q')
    BEGIN
      insert into questions_fts(questions_fts, rowid, desc) values('delete', old.id, old.desc);
    END;
    CREATE TRIGGER questions_fts_au_was_question AFTER UPDATE on tasks
    WHEN old.task_type = (select id from task_types where short_name = 'Q') and new.task_type = old.task_type
    BEGIN
      insert into questions_fts(questions_fts, rowid, desc) values('delete', old.id, old.desc);
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;
    CREATE TRIGGER questions_fts_au_new_is_question AFTER UPDATE on tasks
    WHEN new.task_type = (select id from task_types where short_name = 'Q') and old.task_type != new.task_type
    BEGIN
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;

    CREATE TABLE projects(
      id integer primary key,
      created_at timestamp default current_timestamp,
      name text,
      template integer,
      priority integer not null default 2);

    CREATE VIEW active_projects as
      with undone_task_count as (
        select
          count(*) as tc,
          project as project
        from tasks
        where completed_at is null
        group by project
      )
      select
        p.id,
        p.created_at,
        p.name,
        p.template,
        p.priority
      from projects as p
      inner join undone_task_count as t
      on p.id = t.project
      where t.tc > 0;

    CREATE TABLE notes (
      id integer primary key,
      note text);

    CREATE VIRTUAL TABLE notes_fts USING fts5(note, content='notes', content_rowid='id');
    CREATE TRIGGER notes_fts_ai AFTER INSERT on notes
    BEGIN
      insert into notes_fts(rowid, note) values(new.id, new.note);
    END;
    CREATE TRIGGER notes_fts_ad AFTER DELETE on notes
    BEGIN
      insert into notes_fts(notes_fts, rowid, note) values('delete', old.id, old.note);
    END;
    CREATE TRIGGER notes_fts_au AFTER UPDATE on notes
    BEGIN
      insert into notes_fts(notes_fts, rowid, note) values('delete', old.id, old.note);
      insert into notes_fts(rowid, note) values(new.id, new.note);
    END;

    CREATE VIEW available_tasks as
      with undone_unsnoozed_tasks as (
        select *
        from tasks as t
        where completed_at is NULL
        and (hide_until is NULL or hide_until < current_timestamp)
      ),
      blocked_by as (
        select
          b.blocked as blocked,
          b.blocker as blocker,
          t.completed_at as completed_at
        from blocks as b
        inner join tasks as t on t.id = b.blocker
        where t.completed_at is null
        union
        select
          t.project as blocked,
          t.id as blocker,
          t.completed_at as completed_at
        from tasks as t
        where t.completed_at is null
        and t.project is not null
      )
      select
        t.id as id,
        t.desc as desc,
        t.project as project_id,
        p.name as project_name,
        t.task_type as task_type_id,
        tt.short_name as short_task_type,
        coalesce(tt.workflow, 'current_tasks') as workflow,
        t.created_at,
        t.hide_until,
        t.completed_at
      from undone_unsnoozed_tasks as t
      left join blocked_by as b on t.id = b.blocked
      left join projects as p on t.project = p.id
      left join task_types as tt on t.task_type = tt.id
      where b.blocker is null
      order by coalesce(p.priority, 1) asc, p.id desc, t.created_at desc;

    CREATE TABLE project_templates(
      id integer primary key,
      name text,
      project_name text,
      created_at timestamp default current_timestamp);

    CREATE TABLE project_template_fields(
      id integer primary key,
      name text);

    CREATE TABLE project_data(
      id integer primary key,
      project integer,
      field integer,
      value text);

    CREATE TABLE project_template_tasks(
      id integer primary key,
      template integer,
      task_desc text,
      format_field integer,
      task_type integer);

    CREATE TABLE project_template_task_links(
      id integer primary key,
      blocked integer,
      blocker integer);

    CREATE VIEW generated_project_tasks as
      select
        tt.id as source,
        format(tt.task_desc, pd.value) as desc,
        p.id as project,
        tt.task_type as task_type
      from project_template_task as tt
      inner join projects as p
        on p.template = tt.template
      left join project_data as pd
        on tt.format_field = pd.field
        and p.id = pd.project;

    CREATE VIEW generated_project_links as
      select
        t1.project as project_id,
        t1.id as blocker,
        t2.id as blocked
      from
        tasks as t1,
        tasks as t2,
        project_template_task_links as ptl
      where t1.source = ptl.blocker
      and t2.source = ptl.blocked
      and t1.project = t2.project;


