current_tasks:
  display: |
    # To do

  tables:
    - |
      select
        desc,
        short_task_type,
        project_name
      from available_tasks;
    - "  {desc} ({short_task_type}) - {project_name}"
  commands:
    - command: "/?"
      to: current_tasks_help
    - command: "/p"
      queries:
        - choices: |
            select
              id as project_id, 
              name as project_name
            from active_projects;
          format: "{project_name}"
          display: "Which project"
        - |
          update projects
          set priority = priority + 2
          where id in (
            select id from active_projects
          );
        - |
          update projects
          set priority = 0
          where id = :project_id
    - command: "/os"
      queries:
        - |
          update projects
          set priority = priority + 2
          where id in (
            select id from active_projects
          )
        - "select null as project_id;"
        - "select null as project_name;"
    - command: "/q"
      queries:
        - |
          insert into tasks(desc, task_type, project)
          values (
            :__input,
            (
              select id
              from task_types
              where short_name = 'Q'
            ),
            :project_id
          );
    - command: "/mt"
      to: "modify_task"
      queries:
        - choices: |
            select
              id as current_task_id,
              desc,
              short_task_type,
              project_id,
              project_name
            from available_tasks
            limit 100;
          format: "{desc} ({short_task_type}) - {project_name}"
          display: "which task?"
    - command: "/dt"
      queries:
        - choices: |
            select
              id as task_id,
              desc,
              short_task_type,
              project_id,
              project_name
            from available_tasks
            limit 100;
          format: "{desc} ({short_task_type}) - {project_name}"
          display: "which task?"
        - "update tasks set completed_at = current_timestamp where id = :task_id;"
    - command: "/m"
      queries:
        - "select 'Review notes for ' || :__input as review_meeting_task_desc;"
        - |
          insert into tasks(desc, task_type)
          values (
            :review_meeting_task_desc,
            (select id from task_types where short_name='R')
          ) returning id as meeting_id
        - bash: "touch .temp_note.md"
        - bash: "nvim .temp_note.md"
          system: true
        - bash: "cat .temp_note.md"
          query: "insert into notes(id, note) values(:meeting_id, :__stdout);"
          multiline: false
    - command: "/sq"
      queries:
        - choices: |
            select rowid as question_id, desc as question_text from
            questions_fts 
            where desc match :__input
            order by rank
          format: "{question_text}"
          display: "Which matching question?"
        - "insert into notes(id, note) values (:question_id, '') on conflict do nothing;"
        - filename: ".temp_note.md"
          template: "{question_answer_content}"
          query: |
              select
                note as question_answer_content
              from notes
              where id = :question_id
        - bash: "nvim .temp_note.md"
          system: true
        - bash: "cat .temp_note.md"
          query: "update notes set note = :__stdout where id = :question_id;"
    - command: "/sn"
      queries:
        - choices: |
            select
              notes_fts.rowid as note_id,
              notes_fts.note as question_answer_content,
              tasks.desc as task_description
            from
            notes_fts, tasks
            where note match :__input
            and notes_fts.rowid = tasks.id
            order by rank
          format: "{task_description}"
          display: "Which matching question / meeting?"
        - filename: ".temp_note.md"
          template: "{question_answer_content}"
        - bash: "nvim .temp_note.md"
          system: true
        - bash: "cat .temp_note.md"
          query: "update notes set note = :__stdout where id = :note_id;"
    - command: "/st"
      to: "__next"
      queries:
        - display: "Which task?"
          format: "{task_description}"
          choices: |
            select
              id as current_task_id,
              desc as task_description,
              coalesce(workflow, 'answer_question')  as __next
            from available_tasks;
    - queries:
        - |
          insert into tasks(desc, project, task_type)
          values (
            :__input,
            :project_id,
            (
              select id
              from task_types
              where short_name = 'S'
            )
          );

current_tasks_help:
  display: |
    /p Switch a project to be top priority
    /vp view details about a project
    /os Organize stuff / switch to no project
    /q (question) add a question
    Add a new task (Quick)
    /mt modify a task
    /st start a task
    /dt Task is done
    /m (meeting name) Start taking notes
    /sq (search term) Search for questions
    /sn Search through notes / answers
    /wf (thing) make a new waiting for task
    /vwf See the things I'm waiting for
    snooze a task till tomorrow
    snooze a task till next week
    modify project template
    apply a template of tasks to a project
    bump a project to be last
    make a set of tasks block one task
    make one task block a set of tasks
  commands:
    - to: current_tasks

answer_question:
  queries:
    - |
      insert into notes(id, note)
      values (
        :current_task_id,
        '# ' || (
          select desc 
          from tasks
          where id = :current_task_id
        )) on conflict do nothing;
    - "select note as notes_content from notes where id = :current_task_id;"
    - filename: ".temp_note.md"
      template: "{notes_content}"
    - bash: "nvim .temp_note.md"
      system: true
    - bash: "cat .temp_note.md"
      query: |
        update notes
        set note = :__stdout
        where id = :current_task_id;
      multiline: false
  display: "Is this now done? (y/n)"
  commands:
    - command: "y"
      to: current_tasks
      queries:
        - |
          update tasks
          set completed_at = current_timestamp
          where id = :current_task_id;
    - command: "n"
      to: current_tasks

modify_task:
  queries:
    - |
      select
        desc as task_description,
        task_type,
        project_id as project_id,
        project_name,
        created_at as task_created_at_time,
        hide_until as task_hidden_till_time
      from tasks_denorm
      where id = :current_task_id
  display: |
    # Modify task
    
    Description /cd: {task_description}
    Type /ct:        {task_type}
    Project /cp:     {project_name}
    created:         {task_created_at_time}
    hidden till /ht: {task_hidden_till_time}
      /ht tomorrow
      /ht next week
      /ht 2025-06-01
    
    /np this is a new project
    /pd this is a piece of data for a project
    /qa this is part of an answer to a question
    /pn this is a general project note
    /b back
  commands:
    - command: "/pd"
      queries:
        - display: "Which project?"
          choices: "select id as project_id, name as project_name from active_projects;"
          format: "{project_name}"
        - display: "which field"
          choices: "select id as field_id, name as field_name from project_template_fields;"


    - command: "/np"
      to: current_tasks
      queries:
        - "insert into projects(id, name) values (:current_task_id, :task_description) on conflict do nothing"
        - |
          update tasks set 
            task_type = (select id from task_types where short_name = 'P')
            project = null,
            desc = 'Come up with next actions: ' | :task_description'
          where id = :current_task_id
    - command: "/ht"
      queries:
        - |
          update tasks set hide_until = case :__input
            when 'tomorrow' then datetime('now', '1 day', 'localtime', 'start of day', 'utc')
            when 'next week' then datetime('now', '1 day', 'weekday 1', 'localtime', 'start of day', 'utc')
            else datetime(:__input, 'localtime', 'start of day', 'utc') end
          where id = :current_task_id;
    - command: "/cp"
      queries:
        - choices: |
            select
              id as selected_project_id,
              name as selected_project_name
            from active_projects
          format: "{selected_project_name}"
          display: "which project?"
        - "update tasks set project = :selected_project_id where id = :current_task_id"
    - command: "/cd"
      queries:
        - "update tasks set desc = :__input where id = :current_task_id"
    - command: "/ct"
      queries:
        - choices: |
            select
              id as selected_task_type_id,
              short_name as selected_task_short_name,
              name as selected_task_type_name
            from task_types
            where short_name <> 'P';
          format: "{selected_task_type_name} ({selected_task_short_name})"
          display: "Which type should it become?"
        - "update tasks set task_type = :selected_task_type_id where id = :current_task_id"
    - command: "/b"
      to: current_tasks


    
schema:
  display: |
    CREATE TABLE tasks(
      id integer primary key,
      source integer,
      desc text,
      project integer,
      task_type integer,
      created_at timestamp default current_timestamp,
      hide_until timestamp,
      completed_at timestamp);

    CREATE TABLE blocks(
      id integer primary key,
      blocked integer,
      blocker integer);

    CREATE TABLE task_types(
      id integer primary key,
      short_name text,
      name text,
      workflow text);

    insert into task_types(short_name, name, workflow)
     values ('P', 'Project', 'modify_project');
    insert into task_types(short_name, name)
     values ('WF', 'Waiting For');
    insert into task_types(short_name, name, workflow)
     values ('R', 'Review Notes', 'edit_notes');
    insert into task_types(short_name, name)
     values ('Q', 'Question');
    insert into task_types(short_name, name)
     values ('T', 'General Task');
    insert into task_types(short_name, name, workflow)
     values ('S', 'Stuff', 'modify_task');

    CREATE VIRTUAL TABLE questions_fts USING fts5(desc, content='tasks', content_rowid='id');
    CREATE TRIGGER questions_fts_ai AFTER INSERT on tasks
    WHEN new.task_type = (select id from task_types where short_name = 'Q')
    BEGIN
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;
    CREATE TRIGGER questions_fts_ad AFTER DELETE on tasks
    WHEN old.task_type = (select id from task_types where short_name = 'Q')
    BEGIN
      insert into questions_fts(questions_fts, rowid, desc) values('delete', old.id, old.desc);
    END;
    CREATE TRIGGER questions_fts_au_was_question AFTER UPDATE on tasks
    WHEN old.task_type = (select id from task_types where short_name = 'Q') and new.task_type = old.task_type
    BEGIN
      insert into questions_fts(questions_fts, rowid, desc) values('delete', old.id, old.desc);
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;
    CREATE TRIGGER questions_fts_au_new_is_question AFTER UPDATE on tasks
    WHEN new.task_type = (select id from task_types where short_name = 'Q') and old.task_type != new.task_type
    BEGIN
      insert into questions_fts(rowid, desc) values(new.id, new.desc);
    END;

    CREATE TABLE projects(
      id integer primary key,
      created_at timestamp default current_timestamp,
      name text,
      template integer,
      priority integer not null default 2);

    CREATE VIEW active_projects as
      with undone_task_count as (
        select
          count(*) as tc,
          project as project
        from tasks
        where completed_at is null
        group by project
      )
      select
        p.id,
        p.created_at,
        p.name,
        p.template,
        p.priority
      from projects as p
      inner join undone_task_count as t
      on p.id = t.project
      where t.tc > 0;

    CREATE TABLE notes (
      id integer primary key,
      note text);

    CREATE VIRTUAL TABLE notes_fts USING fts5(note, content='notes', content_rowid='id');
    CREATE TRIGGER notes_fts_ai AFTER INSERT on notes
    BEGIN
      insert into notes_fts(rowid, note) values(new.id, new.note);
    END;
    CREATE TRIGGER notes_fts_ad AFTER DELETE on notes
    BEGIN
      insert into notes_fts(notes_fts, rowid, note) values('delete', old.id, old.note);
    END;
    CREATE TRIGGER notes_fts_au AFTER UPDATE on notes
    BEGIN
      insert into notes_fts(notes_fts, rowid, note) values('delete', old.id, old.note);
      insert into notes_fts(rowid, note) values(new.id, new.note);
    END;

    create view tasks_denorm as
      select
        t.id as id,
        t.desc as desc,
        t.project as project_id,
        p.name as project_name,
        t.task_type as task_type_id,
        tt.short_name as short_task_type,
        tt.name as task_type,
        coalesce(tt.workflow, 'current_tasks') as workflow,
        t.created_at,
        t.hide_until,
        t.completed_at
      from tasks as t
      left join task_types as tt
      on tt.id = t.task_type
      left join projects
      on t.project = p.id
      where t.id = :current_task_id;

    CREATE VIEW available_tasks as
      with undone_unsnoozed_tasks as (
        select *
        from tasks as t
        where completed_at is NULL
        and (hide_until is NULL or hide_until < current_timestamp)
      ),
      blocked_by as (
        select
          b.blocked as blocked,
          b.blocker as blocker,
          t.completed_at as completed_at
        from blocks as b
        inner join tasks as t on t.id = b.blocker
        where t.completed_at is null
        union
        select
          t.project as blocked,
          t.id as blocker,
          t.completed_at as completed_at
        from tasks as t
        where t.completed_at is null
        and t.project is not null
      )
      select
        t.id as id,
        t.desc as desc,
        t.project as project_id,
        p.name as project_name,
        t.task_type as task_type_id,
        tt.short_name as short_task_type,
        coalesce(tt.workflow, 'current_tasks') as workflow,
        t.created_at,
        t.hide_until,
        t.completed_at
      from undone_unsnoozed_tasks as t
      left join blocked_by as b on t.id = b.blocked
      left join projects as p on t.project = p.id
      left join task_types as tt on t.task_type = tt.id
      where b.blocker is null
      order by coalesce(p.priority, 1) asc, p.id desc, t.created_at desc;

    CREATE TABLE project_templates(
      id integer primary key,
      name text,
      project_name text,
      created_at timestamp default current_timestamp);

    CREATE TABLE project_template_fields(
      id integer primary key,
      name text);

    CREATE TABLE project_data(
      id integer primary key,
      project integer,
      field integer,
      value text);

    CREATE TABLE project_template_tasks(
      id integer primary key,
      template integer,
      task_desc text,
      format_field integer,
      task_type integer);

    CREATE TABLE project_template_task_links(
      id integer primary key,
      blocked integer,
      blocker integer);

    CREATE VIEW generated_project_tasks as
      select
        tt.id as source,
        format(tt.task_desc, pd.value) as desc,
        p.id as project,
        tt.task_type as task_type
      from project_template_task as tt
      inner join projects as p
        on p.template = tt.template
      left join project_data as pd
        on tt.format_field = pd.field
        and p.id = pd.project;

    CREATE VIEW generated_project_links as
      select
        t1.project as project_id,
        t1.id as blocker,
        t2.id as blocked
      from
        tasks as t1,
        tasks as t2,
        project_template_task_links as ptl
      where t1.source = ptl.blocker
      and t2.source = ptl.blocked
      and t1.project = t2.project;


